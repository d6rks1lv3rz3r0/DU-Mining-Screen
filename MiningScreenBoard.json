{
    "slots": {
        "0": {
            "name": "slot1",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "1": {
            "name": "slot2",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "2": {
            "name": "slot3",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "3": {
            "name": "slot4",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "4": {
            "name": "slot5",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "5": {
            "name": "slot6",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "6": {
            "name": "slot7",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "7": {
            "name": "slot8",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "8": {
            "name": "slot9",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "9": {
            "name": "slot10",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-1": {
            "name": "unit",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-3": {
            "name": "player",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-2": {
            "name": "construct",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-4": {
            "name": "system",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-5": {
            "name": "library",
            "type": {
                "events": [],
                "methods": []
            }
        }
    },
    "handlers": [
        {
            "code": "Screen.deactivate()\n\nif Emitter then\n    Message = Screen.getScriptOutput()\n    Emitter.send('MiningScreen',Message)\nend ",
            "filter": {
                "args": [],
                "signature": "onStop()",
                "slotKey": "-1"
            },
            "key": "0"
        },
        {
            "code": "UpdateScreen()",
            "filter": {
                "args": [
                    {
                        "value": "Update"
                    }
                ],
                "signature": "onTimer(tag)",
                "slotKey": "-1"
            },
            "key": "1"
        },
        {
            "code": "unit.hideWidget()\n\nmucount = 0\n\nfor _, value in pairs(unit) do\n    if type(value) == \"table\" and type(value.export) == \"table\" then -- it's an element\n        if value.getActiveOre then\n            mucount = mucount + 1;\n            if mucount == 1 then\n                MiningUnit1 = value\n            elseif mucount == 2 then\n                MiningUnit2 = value\n            elseif mucount == 3 then\n                MiningUnit3 = value\n            elseif mucount == 4 then\n                MiningUnit4 = value\n            elseif mucount == 5 then\n                MiningUnit5 = value\n            elseif mucount == 6 then\n                MiningUnit6 = value\n            elseif mucount == 7 then\n                MiningUnit7 = value         \n            end\n        elseif value.send then\n            Emitter = value\n        elseif value.getItemsVolume then\n            Container = value\n        elseif value.setRenderScript then\n            Screen = value\n        end\n    end\nend\n\nif not Screen then error(\"Screen is not connected.\") end\nif not Container then error(\"Databank is not connected.\") end\nif not MiningUnit1 then error(\"No Mining Unit is not connected.\") end\n\nScreen.setScriptInput('')\n\n-- Converts \"if variable\" to 1,0 for easier checking.\nfunction exists(var)\n    if var then check=1 else check=0 end\n    return check\nend\n\n-- Converts boolean to 1,0 for easier checking.\nboolTonumber={[true]=1,[false]=0}\n\n-- Rounds \nfunction round(num, numDecimalPlaces)\n  local mult = 10^(numDecimalPlaces or 0)\n  return math.floor(num * mult + 0.5) / mult\nend\n\n-- Update Screen \nfunction UpdateScreen()\n    ContainerContentMass = round(Container.getItemsMass())\n    ContainerContentVol = round(Container.getItemsVolume())\n    ContainerContentMaxVol = round(Container.getMaxVolume())\n    \n    ConstructPos = construct.getWorldPosition();\n    ConstructPosString = math.ceil(ConstructPos[1]) .. ',' \n    .. math.ceil(ConstructPos[2]) .. ',' .. math.ceil(ConstructPos[3])\n    \n    AcquiredTime = system.getArkTime()\n\n    Header = tostring(NMUs) .. '$' .. tostring(ContainerContentMass) .. \n    '$' .. tostring(ContainerContentVol) .. '$' .. tostring(ContainerContentMaxVol) .. '$' .. \n    construct.getName() ..'$' .. boolTonumber[ReplaceGreenWithBlue] .. '$' .. \n    boolTonumber[ReplaceRedWithBlue] .. '$' .. ConstructPosString .. '$' .. AcquiredTime\n    .. '$' .. tostring(construct.getId())\n\n    Data = ''\n    for ii = 1,NMUs do\n\n        MiningUnit = MiningUnits[ii]\n\n        State = MiningUnit.getState()\n        OreID = MiningUnit.getActiveOre()\n        OreInfo = system.getItem(OreID)\n        BaseRate = MiningUnit.getBaseRate()\n        Efficiency = MiningUnit.getEfficiency()\n        Adjacency = MiningUnit.getAdjacencyBonus()\n\n        CalibrationRate = MiningUnit.getCalibrationRate()\n\n        if UseOptimalRate then\n            OptimalRate = MiningUnit.getOptimalRate()\n        else\n            OptimalRate = RateThreshold\n        end\n\n        ProductionRate = MiningUnit.getProductionRate()\n\n        Cooldown = MiningUnit.getLastExtractionTime()    \n        Position = MiningUnit.getLastExtractionPosition()\n\n        CurrentMUStats = tostring(State) .. '$' .. OreID .. '$' .. tostring(BaseRate) .. '$' ..\n        tostring(Efficiency) .. '$' .. tostring(Adjacency) .. '$' .. tostring(CalibrationRate) ..\n        '$' .. tostring(OptimalRate) .. '$' .. tostring(ProductionRate) .. '$' .. tostring(Cooldown) .. \n        '$' .. tostring(Position[1]) .. ',' .. tostring(Position[2]) .. ',' .. tostring(Position[3])\n\n        Data = Data .. '#' .. CurrentMUStats\n\n    end\n\n    Message = Header .. \"&\" .. Data \n    Screen.setScriptInput(Message)\n    \nend\n\n-- Parameters --\nUseOptimalRate = false --export: Toggle to Use Reported Optimal Rates for Calibration Times\nRateThreshold = 0.50 --export: Alternative Threshold Rate to be Used for Calibration Times\nReplaceGreenWithBlue = false --export: Colorblind Option I\nReplaceRedWithBlue = false --export: Colorblind Option II\n\n-- Dynamic Slot Allocation --\n\nNMUs = exists(MiningUnit1)+exists(MiningUnit2)+exists(MiningUnit3)+exists(MiningUnit4)\n+exists(MiningUnit5)+exists(MiningUnit6)+exists(MiningUnit7)\n\nMiningUnits = {MiningUnit1,MiningUnit2,MiningUnit3,MiningUnit4,\n    MiningUnit5,MiningUnit6,MiningUnit7}\n\nScreen.activate()\n\nUpdateScreen()\nunit.setTimer('Update',3)\n\nScreen.setRenderScript([[\n--------------------------------------------------- Creates the Screen Background Effects ----------------------------------------------------(1)\nlocal function Background(Logo,Aura0,Aura1,r,g,b,ar,ag,ab)\n    \n    local rx, ry = getResolution()\n    local vw = rx/100\n    local vh = ry/100\n\n    --- Main Color ---\n    local r = r or 0\n    local g = g or 0.2\n    local b = b or 0.8\n    \n    --- Accent Color ---\n    local ar = ar or 0\n    local ag = ag or 0.4\n    local ab = ab or 0.8\n\n    setBackgroundColor(0.05*r,0.05*g,0.05*b)\n\n    for ii = 3,165,8 do\n        setNextStrokeColor(Aura0,r,g,b,0.05)\n        setNextStrokeWidth(Aura0,0.05*vh)\n        addLine(Aura0,ii*vh,0,ii*vh,ry)\n    end\n\n    for ii = 6,98,8 do\n        setNextStrokeColor(Aura0,r,g,b,0.05)\n        setNextStrokeWidth(Aura0,0.05*vh)\n        addLine(Aura0,0,ii*vh,rx,ii*vh)\n    end\n\n    local PX = {0,1}\n    local PY = {0.03,0.03}\n\n    for ii = 1,#PX-1,1 do\n        setNextStrokeColor(Aura1,ar,ag,ab, 1) \n        addLine(Aura1, PX[ii]*rx, PY[ii]*ry, PX[ii+1]*rx, PY[ii+1]*ry) \n    end\n\n    for ii = 1,#PX-1,1 do\n        setNextStrokeColor(Aura1,ar,ag,ab, 1) \n        addLine(Aura1, PX[ii]*rx, ry-PY[ii]*ry, PX[ii+1]*rx, ry-PY[ii+1]*ry) \n    end\n\nend\n\n--------------------------------------------------- Draws Center Spinner of a Mining Unit ----------------------------------------------------(2)\nlocal function MiningModule(Front,Back,X,Y,Scale,ThetaOffset,ThetaMultiplier,r,g,b,a,Angle,thickness)\n    \n    local rx, ry = getResolution()\n    local vw = rx/100\n    local vh = ry/100\n\n    local CubeO = {{-0.45,-0.23,0},{-0.45,-0.11,0},{-0.38,-0.11,0.07},{-0.11,0.4,0.34},{-0.11,0.5,0.34},{0,0.5,0.45},{0,-0.23,0.45},{-0.45,-0.23,0},{-0.45,-0.11,0},{-0.38,-0.11,-0.07},{-0.11,0.4,-0.34},{-0.11,0.5,-0.34},{0,0.5,-0.45},{0,-0.23,-0.45},{-0.45,-0.23,0}}\n\n    local CubeI = {{-0.38,-0.11,0},{-0.11,0.4,0.27},{-0.11,0.5,0.27},{-0.38,0.5,0},{-0.38,-0.11,0},{-0.11,0.4,-0.27},{-0.11,0.5,-0.27},{-0.38,0.5,0}}\n\n    local Wing1 = {{-0.89,-0.02,0},{-0.82,-0.05,0.07},{-0.41,0.36,0.34},{-0.38,0.45,0.34},{-0.71,0.56,0},{-0.89,-0.02,0},{-0.82,-0.05,-0.07},{-0.41,0.36,-0.34},{-0.38,0.45,-0.34},{-0.71,0.56,0}}\n\n    local Wing2 = {{-0.94,-0.22,0},{-0.88,-0.24,0.06},{-0.68,-0.04,0.19},{-0.65,0.04,0.19},{-0.44,0.26,0.33},{-0.41,0.36,0.33},{-0.88,-0.03,0},{-0.94,-0.22,0},{-0.88,-0.24,-0.06},{-0.68,-0.04,-0.19},{-0.65,0.04,-0.19},{-0.44,0.26,-0.33},{-0.41,0.36,-0.33},{-0.88,-0.03,0}}\n\n    local Wing3 = {{-0.99,-0.42,0},{-0.94,-0.44,0.05},{-0.74,-0.23,0.18},{-0.68,-0.04,0.18},{-0.93,-0.23,0},{-0.99,-0.42,0},{-0.94,-0.44,-0.05},{-0.74,-0.23,-0.18},{-0.68,-0.04,-0.18},{-0.93,-0.23,0}}\n    \n    local CubeOM = {{0.45,-0.23,0},{0.45,-0.11,0},{0.38,-0.11,0.07},{0.11,0.4,0.34},{0.11,0.5,0.34},{0,0.5,0.45},{0,-0.23,0.45},{0.45,-0.23,0},{0.45,-0.11,0},{0.38,-0.11,-0.07},{0.11,0.4,-0.34},{0.11,0.5,-0.34},{0,0.5,-0.45},{0,-0.23,-0.45},{0.45,-0.23,0}}\n\n    local CubeIM = {{0.38,-0.11,0},{0.11,0.4,0.27},{0.11,0.5,0.27},{0.38,0.5,0},{0.38,-0.11,0},{0.11,0.4,-0.27},{0.11,0.5,-0.27},{0.38,0.5,0}}\n\n    local Wing1M = {{0.89,-0.02,0},{0.82,-0.05,0.07},{0.41,0.36,0.34},{0.38,0.45,0.34},{0.71,0.56,0},{0.89,-0.02,0},{0.82,-0.05,-0.07},{0.41,0.36,-0.34},{0.38,0.45,-0.34},{0.71,0.56,0}}\n\n    local Wing2M = {{0.94,-0.22,0},{0.88,-0.24,0.06},{0.68,-0.04,0.19},{0.65,0.04,0.19},{0.44,0.26,0.33},{0.41,0.36,0.33},{0.88,-0.03,0},{0.94,-0.22,0},{0.88,-0.24,-0.06},{0.68,-0.04,-0.19},{0.65,0.04,-0.19},{0.44,0.26,-0.33},{0.41,0.36,-0.33},{0.88,-0.03,0}}\n\n    local Wing3M = {{0.99,-0.42,0},{0.94,-0.44,0.05},{0.74,-0.23,0.18},{0.68,-0.04,0.18},{0.93,-0.23,0},{0.99,-0.42,0},{0.94,-0.44,-0.05},{0.74,-0.23,-0.18},{0.68,-0.04,-0.18},{0.93,-0.23,0}}\n\n    local theta = ThetaOffset - ThetaMultiplier*getTime() \n    local pers = Angle\n    \n    local thickness = thickness or 0.1*vh\n    \n    local sin = math.sin\n    local cos = math.cos\n    local rad = math.rad\n    \n    local function Rotate3DYX(TableRowXYZ,theta,pers)\n        \n        local X,Y,Z = table.unpack(TableRowXYZ)\n        \n        local C1 = X*cos(rad(-theta)) + Z*sin(rad(-theta))\n        local C3 = - X*sin(rad(-theta)) + Z*cos(rad(-theta))\n\n        local C2 = Y*cos(rad(pers)) - C3*sin(rad(pers))\n        local C3 = Y*sin(rad(pers)) + C3*cos(rad(pers))\n\n        return {-C1,C2,C3}\n        \n    end\n    \n    local sa = 0\n    \n    setDefaultStrokeColor(Front,Shape_Line,r,g,b,a)\n    setDefaultStrokeColor(Back,Shape_Line,r,g,b,a)\n    \n    setDefaultStrokeWidth(Front,Shape_Line,thickness)\n    setDefaultStrokeWidth(Back,Shape_Line,thickness)\n    \n    setDefaultShadow(Front,Shape_Line,0.5*vh,r,g,b,sa)\n    setDefaultShadow(Back,Shape_Line,0.5*vh,r,g,b,sa)\n\n    for ii = 1,#CubeO do       \n        CubeO[ii] = Rotate3DYX(CubeO[ii],theta,pers) \n        CubeOM[ii] = Rotate3DYX(CubeOM[ii],theta,pers) \n        if ii > 1 then\n            if CubeO[ii][3] >= 0 then\n                addLine(Front,CubeO[ii][1]*Scale + X,CubeO[ii][2]*Scale + Y,CubeO[ii -1][1]*Scale + X,CubeO[ii -1][2]*Scale + Y)\n            else\n                addLine(Back,CubeO[ii][1]*Scale + X,CubeO[ii][2]*Scale + Y,CubeO[ii -1][1]*Scale + X,CubeO[ii -1][2]*Scale + Y)\n            end\n            if CubeOM[ii][3] >= 0 then\n                addLine(Front,CubeOM[ii][1]*Scale + X,CubeOM[ii][2]*Scale + Y,CubeOM[ii -1][1]*Scale + X,CubeOM[ii -1][2]*Scale + Y)\n            else\n                addLine(Back,CubeOM[ii][1]*Scale + X,CubeOM[ii][2]*Scale + Y,CubeOM[ii -1][1]*Scale + X,CubeOM[ii -1][2]*Scale + Y)\n            end\n        end\n    end\n\n    for ii = 1,#CubeI do\n        CubeI[ii] = Rotate3DYX(CubeI[ii],theta,pers)\n        CubeIM[ii] = Rotate3DYX(CubeIM[ii],theta,pers)       \n        if ii > 1 then\n            if CubeI[ii][3] >= 0 then\n                addLine(Front,CubeI[ii][1]*Scale + X,CubeI[ii][2]*Scale + Y,CubeI[ii -1][1]*Scale + X,CubeI[ii -1][2]*Scale + Y)\n            else\n                addLine(Back,CubeI[ii][1]*Scale + X,CubeI[ii][2]*Scale + Y,CubeI[ii -1][1]*Scale + X,CubeI[ii -1][2]*Scale + Y)\n            end\n            if CubeOM[ii][3] >= 0 then\n                addLine(Front,CubeIM[ii][1]*Scale + X,CubeIM[ii][2]*Scale + Y,CubeIM[ii -1][1]*Scale + X,CubeIM[ii -1][2]*Scale + Y)\n            else\n                addLine(Back,CubeIM[ii][1]*Scale + X,CubeIM[ii][2]*Scale + Y,CubeIM[ii -1][1]*Scale + X,CubeIM[ii -1][2]*Scale + Y)\n            end\n        end\n    end\n\n    for ii = 1,#Wing1 do\n        Wing1[ii] = Rotate3DYX(Wing1[ii],theta,pers)\n        Wing1M[ii] = Rotate3DYX(Wing1M[ii],theta,pers)\n        if ii > 1 then\n            if Wing1[ii][3] >= 0 then\n                addLine(Front,Wing1[ii][1]*Scale + X,Wing1[ii][2]*Scale + Y,Wing1[ii -1][1]*Scale + X,Wing1[ii -1][2]*Scale + Y)\n            else\n                addLine(Back,Wing1[ii][1]*Scale + X,Wing1[ii][2]*Scale + Y,Wing1[ii -1][1]*Scale + X,Wing1[ii -1][2]*Scale + Y)\n            end\n            if Wing1M[ii][3] >= 0 then\n                addLine(Front,Wing1M[ii][1]*Scale + X,Wing1M[ii][2]*Scale + Y,Wing1M[ii -1][1]*Scale + X,Wing1M[ii -1][2]*Scale + Y)\n            else\n                addLine(Back,Wing1M[ii][1]*Scale + X,Wing1M[ii][2]*Scale + Y,Wing1M[ii -1][1]*Scale + X,Wing1M[ii -1][2]*Scale + Y)\n            end\n        end\n    end\n\n    for ii = 1,#Wing2 do\n        Wing2[ii] = Rotate3DYX(Wing2[ii],theta,pers)\n        Wing2M[ii] = Rotate3DYX(Wing2M[ii],theta,pers)\n        if ii > 1 then\n            if Wing2[ii][3] >= 0 then\n                addLine(Front,Wing2[ii][1]*Scale + X,Wing2[ii][2]*Scale + Y,Wing2[ii -1][1]*Scale + X,Wing2[ii -1][2]*Scale + Y)\n            else\n                addLine(Back,Wing2[ii][1]*Scale + X,Wing2[ii][2]*Scale + Y,Wing2[ii -1][1]*Scale + X,Wing2[ii -1][2]*Scale + Y)\n            end\n            if Wing2M[ii][3] >= 0 then\n                addLine(Front,Wing2M[ii][1]*Scale + X,Wing2M[ii][2]*Scale + Y,Wing2M[ii -1][1]*Scale + X,Wing2M[ii -1][2]*Scale + Y)\n            else\n                addLine(Back,Wing2M[ii][1]*Scale + X,Wing2M[ii][2]*Scale + Y,Wing2M[ii -1][1]*Scale + X,Wing2M[ii -1][2]*Scale + Y)\n            end\n        end\n    end\n\n    for ii = 1,#Wing3 do\n        Wing3[ii] = Rotate3DYX(Wing3[ii],theta,pers)\n        Wing3M[ii] = Rotate3DYX(Wing3M[ii],theta,pers)\n        if ii > 1 then\n            if Wing3[ii][3] >= 0 then\n                addLine(Front,Wing3[ii][1]*Scale + X,Wing3[ii][2]*Scale + Y,Wing3[ii -1][1]*Scale + X,Wing3[ii -1][2]*Scale + Y)\n            else\n                addLine(Back,Wing3[ii][1]*Scale + X,Wing3[ii][2]*Scale + Y,Wing3[ii -1][1]*Scale + X,Wing3[ii -1][2]*Scale + Y)\n            end\n            if Wing3M[ii][3] >= 0 then\n                addLine(Front,Wing3M[ii][1]*Scale + X,Wing3M[ii][2]*Scale + Y,Wing3M[ii -1][1]*Scale + X,Wing3M[ii -1][2]*Scale + Y)\n            else\n                addLine(Back,Wing3M[ii][1]*Scale + X,Wing3M[ii][2]*Scale + Y,Wing3M[ii -1][1]*Scale + X,Wing3M[ii -1][2]*Scale + Y)\n            end\n        end\n    end\n    \nend\n\n--------------------------------------------------- Draws Base Support of a Mining Unit ----------------------------------------------------(3)\nlocal function DrawBase(Front,Back,X,Y,Scale,r,g,b,a)\n    \n    local rx, ry = getResolution()\n    local vw = rx/100\n    local vh = ry/100\n    \n    local CX = 114\n\n    local X1 = { 26, 2, 31, 34, 44, 52, 58, 66, 66, 114, 114, 73, 58, 51, 41, 26, 55, 51, 38, 27, 48, 60, 72, 93, 93, 96, 101, 101, 87, 87, 101, 101, 91, 76}\n    local Y1 = {190, 175, 98, 96,65, 59, 44, 42, 11, 21,129,112,155, 157, 186, 190, 107, 98, 132, 127,73, 77, 83, 58, 38, 34, 41, 63, 84, 93, 96, 110, 105, 103}\n\n    local X2 = {51,59}\n    local Y2 = {98,76.65}\n\n    local X3 = {34,40.7}\n    local Y3 = {96,91.77}\n\n    local X4 = {72,77,80,73}\n    local Y4 = {83,86,92,112}\n\n    local X5 = {101,101,96,80,75,77}\n    local Y5 = {119.5,41,34,29,36,77}\n\n    local X6 = {66,68}\n    local Y6 = {42,81}\n\n    local X7 = {66,114}\n    local Y7 = {11,1}\n\n    local X8 = {101,78,78}\n    local Y8 = {119,110,103.5}\n\n    local sa = 0\n    \n    setDefaultStrokeColor(Front,Shape_Line,r,g,b,a)\n    setDefaultStrokeColor(Back,Shape_Line,r,g,b,a)\n\n    setDefaultStrokeWidth(Front,Shape_Line,0.25*vh)\n    setDefaultStrokeWidth(Back,Shape_Line,0.25*vh)\n\n    setDefaultShadow(Front,Shape_Line,0.5*vh,r,g,b,sa)\n    setDefaultShadow(Back,Shape_Line,0.5*vh,r,g,b,sa)\n\n    for ii = 1,#X1 - 1 do\n\n        addLine(Front,(X1[ii] - CX)*Scale + X,Y1[ii]*Scale + Y,(X1[ii+1] - CX)*Scale + X,Y1[ii+1]*Scale + Y)\n        addLine(Front,-(X1[ii] - CX)*Scale + X,Y1[ii]*Scale + Y,-(X1[ii+1] - CX)*Scale + X,Y1[ii+1]*Scale + Y)\n\n    end\n\n    addLine(Front,(X2[1] - CX)*Scale + X,Y2[1]*Scale + Y,(X2[2] - CX)*Scale + X,Y2[2]*Scale + Y)\n    addLine(Front,(X3[1] - CX)*Scale + X,Y3[1]*Scale + Y,(X3[2] - CX)*Scale + X,Y3[2]*Scale + Y)\n    addLine(Front,(X6[1] - CX)*Scale + X,Y6[1]*Scale + Y,(X6[2] - CX)*Scale + X,Y6[2]*Scale + Y)\n    addLine(Back,(X7[1] - CX)*Scale + X,Y7[1]*Scale + Y,(X7[2] - CX)*Scale + X,Y7[2]*Scale + Y)\n    \n    addLine(Front,-(X2[1] - CX)*Scale + X,Y2[1]*Scale + Y,-(X2[2] - CX)*Scale + X,Y2[2]*Scale + Y)\n    addLine(Front,-(X3[1] - CX)*Scale + X,Y3[1]*Scale + Y,-(X3[2] - CX)*Scale + X,Y3[2]*Scale + Y)\n    addLine(Front,-(X6[1] - CX)*Scale + X,Y6[1]*Scale + Y,-(X6[2] - CX)*Scale + X,Y6[2]*Scale + Y)\n    addLine(Back,-(X7[1] - CX)*Scale + X,Y7[1]*Scale + Y,-(X7[2] - CX)*Scale + X,Y7[2]*Scale + Y)\n\n    for ii = 1,#X4 - 1 do\n\n        addLine(Front,(X4[ii] - CX)*Scale + X,Y4[ii]*Scale + Y,(X4[ii+1] - CX)*Scale + X,Y4[ii+1]*Scale + Y)\n        addLine(Front,-(X4[ii] - CX)*Scale + X,Y4[ii]*Scale + Y,-(X4[ii+1] - CX)*Scale + X,Y4[ii+1]*Scale + Y)\n\n    end\n\n    for ii = 1,#X5 - 1 do\n\n        addLine(Front,(X5[ii] - CX)*Scale + X,Y5[ii]*Scale + Y,(X5[ii+1] - CX)*Scale + X,Y5[ii+1]*Scale + Y)\n        addLine(Front,-(X5[ii] - CX)*Scale + X,Y5[ii]*Scale + Y,-(X5[ii+1] - CX)*Scale + X,Y5[ii+1]*Scale + Y)\n\n    end\n\n    for ii = 1,#X8 - 1 do\n\n        addLine(Front,(X8[ii] - CX)*Scale + X,Y8[ii]*Scale + Y,(X8[ii+1] - CX)*Scale + X,Y8[ii+1]*Scale + Y)\n        addLine(Front,-(X8[ii] - CX)*Scale + X,Y8[ii]*Scale + Y,-(X8[ii+1] - CX)*Scale + X,Y8[ii+1]*Scale + Y)\n        \n    end\n\nend\n\n--------------------------------------------------- Draws Static Top Cap of a Mining Unit ----------------------------------------------------(4)\nlocal function MiningModuleCap(Front,X,Y,Scale,ThetaOffset,ThetaMultiplier,r,g,b,a)\n    \n    local rx, ry = getResolution()\n    local vw = rx/100\n    local vh = ry/100\n\n    local CubeO = {{-0.45,-0.23,0},{0,-0.23,-0.45},{0.45,-0.23,0},{0,-0.23,0.45},{-0.45,-0.23,0},{-0.45,0.1,0},{0,0.1,0.45},{0.45,0.1,0},{0.45,-0.23,0}}\n    \n    local pers = -15\n    local sa = 0\n    \n    local sin = math.sin\n    local cos = math.cos\n    local rad = math.rad\n\n    for ii = 1,#CubeO do\n        local C = CubeO[ii]\n       \n        local C2 = C[2]*cos(rad(pers)) - C[3]*sin(rad(pers))\n        local C3 = C[2]*sin(rad(pers)) + C[3]*cos(rad(pers))\n\n        CubeO[ii][2] = C2\n        CubeO[ii][3] = C3\n    end\n    \n    setDefaultStrokeColor(Front,Shape_Polygon,r,g,b,a)\n    setDefaultStrokeWidth(Front,Shape_Polygon,0.25*vh)\n    setDefaultShadow(Front,Shape_Polygon,0.5*vh,r,g,b,sa)\n    setDefaultFillColor(Front,Shape_Polygon,0,0.05*0.2,0.05*0.8,0)\n\n    addQuad(Front,CubeO[1][1]*Scale + X,CubeO[1][2]*Scale + Y,CubeO[2][1]*Scale + X,CubeO[2][2]*Scale + Y,CubeO[3][1]*Scale + X,CubeO[3][2]*Scale + Y,CubeO[4][1]*Scale + X,CubeO[4][2]*Scale + Y)\n    addQuad(Front,CubeO[4][1]*Scale + X,CubeO[4][2]*Scale + Y,CubeO[5][1]*Scale + X,CubeO[5][2]*Scale + Y,CubeO[6][1]*Scale + X,CubeO[6][2]*Scale + Y,CubeO[7][1]*Scale + X,CubeO[7][2]*Scale + Y)\n    addQuad(Front,CubeO[4][1]*Scale + X,CubeO[4][2]*Scale + Y,CubeO[9][1]*Scale + X,CubeO[9][2]*Scale + Y,CubeO[8][1]*Scale + X,CubeO[8][2]*Scale + Y,CubeO[7][1]*Scale + X,CubeO[7][2]*Scale + Y)\n        \nend\n\n---------------------------------------------- Draws a Partial or Full Hexagon with Perspective -------------------------------------------------(5)\nlocal function addHexagon(Front,Center,Back,CX,CY,EdgeLength,pers,r,g,b,a,str,stg,stb,sta,strokewidth,hextype)\n    \n    local rx, ry = getResolution()\n    local vw = rx/100\n    local vh = ry/100\n    \n    local ii = 0\n    local jj = 0\n    \n    local sin = math.sin\n    local cos = math.cos\n    local rad = math.rad\n    local sqrt = math.sqrt\n    \n    local X1 = (ii - EdgeLength/2)*vh\n    local Y1 = (jj - EdgeLength*sqrt(3)/2)*vh\n    local X2 = (ii - EdgeLength)*vh\n    local Y2 = (jj - 0)*vh\n    local X3 = (ii - EdgeLength/2)*vh\n    local Y3 = (jj + EdgeLength*sqrt(3)/2)*vh\n    local X4 = (ii + EdgeLength/2)*vh\n    local Y4 = (jj + EdgeLength*sqrt(3)/2)*vh\n    local X5 = (ii + EdgeLength)*vh\n    local Y5 = (jj - 0)*vh\n    local X6 = (ii + EdgeLength/2)*vh\n    local Y6 = (jj - EdgeLength*sqrt(3)/2)*vh\n    \n    local Y1 = (Y1-jj)*cos(rad(pers))\n    local Z1 = (Y1-jj)*sin(rad(pers))\n    local Y2 = (Y2-jj)*cos(rad(pers))\n    local Z2 = (Y2-jj)*sin(rad(pers))\n    local Y3 = (Y3-jj)*cos(rad(pers))\n    local Z3 = (Y3-jj)*sin(rad(pers))\n    local Y4 = (Y4-jj)*cos(rad(pers))\n    local Z4 = (Y4-jj)*sin(rad(pers))\n    local Y5 = (Y5-jj)*cos(rad(pers))\n    local Z5 = (Y5-jj)*sin(rad(pers))\n    local Y6 = (Y6-jj)*cos(rad(pers))\n    local Z6 = (Y6-jj)*sin(rad(pers))\n\n    local X1 = X1 + CX\n    local Y1 = Y1 + CY\n    local X2 = X2 + CX\n    local Y2 = Y2 + CY\n    local X3 = X3 + CX\n    local Y3 = Y3 + CY\n    local X4 = X4 + CX\n    local Y4 = Y4 + CY\n    local X5 = X5 + CX\n    local Y5 = Y5 + CY\n    local X6 = X6 + CX\n    local Y6 = Y6 + CY\n\n    setDefaultFillColor(Back,Shape_Polygon,r,g,b,a)\n    setDefaultStrokeColor(Back,Shape_Polygon,r,g,b,0)\n    setDefaultStrokeWidth(Back,Shape_Polygon,0.1)         \n\n    addQuad(Back,X6 - 0.55,Y6,X1,Y1,X2,Y2,X3 - 0.55,Y3)\n    addQuad(Back,X3 + 0.55,Y3,X4,Y4,X5,Y5,X6 + 0.55,Y6)\n\n    setDefaultStrokeColor(Front,Shape_Line,str,stg,stb,sta)\n    setDefaultStrokeWidth(Front,Shape_Line,strokewidth)\n    \n    setDefaultStrokeColor(Center,Shape_Line,str,stg,stb,sta)\n    setDefaultStrokeWidth(Center,Shape_Line,strokewidth)\n    \n    if hextype == 1 then\n\n        addLine(Center,X1,Y1,X2,Y2)\n        addLine(Center,X2,Y2,X3,Y3)\n        addLine(Front,X3,Y3,X4,Y4)\n        addLine(Center,X4,Y4,X5,Y5)\n        addLine(Center,X5,Y5,X6,Y6)\n        addLine(Center,X6,Y6,X1,Y1)\n        \n    elseif hextype == 2 then\n        \n        addLine(Center,X1,Y1,X2,Y2)        \n        addLine(Front,X3,Y3,X4,Y4)        \n        addLine(Center,X5,Y5,X6,Y6)       \n        \n    elseif hextype == 3 then\n        \n        addLine(Center,X2,Y2,X3,Y3)\n        addLine(Center,X4,Y4,X5,Y5)\n        addLine(Center,X6,Y6,X1,Y1)\n        \n    end\n\nend\n\n---------------------------------------------- Draws a Fully Assembled Mining Unit Top Down -------------------------------------------------(6)\nlocal function DrawMiningUnitTopDown(Front,Center,Back,X,Y,working)\n    \n    local rx, ry = getResolution()\n    local vw = rx/100\n    local vh = ry/100\n    \n    local r,g,b,a = 0.8,0.8,0.2,1\n    local rot = 0\n    local offset = 0\n    local phase = 90\n    \n    if working == 2 then \n        if GColorblind == 1 then\n            r,g,b,a = 0,0.5,1,1\n        else\n            r,g,b,a = 0,1,0.5,1\n        end\n        rot = 120\n        offset = 45\n        phase = 0\n    elseif working == 1 then\n        if RColorblind == 1 then\n            r,g,b,a = 0,0.5,1,1\n        else\n            r,g,b,a = 1,0.2,0.2,1\n        end      \n        rot = 0\n        offset = 45\n        phase = 0\n    end\n\n    MiningModule(Front,Back,X,Y,10*vh,offset,rot,r,g,b,a,-90,0.25*vh)\n    MiningModule(Front,Back,X,Y,10*vh,phase-offset,-rot,r,g,b,a,-90,0.25*vh)\n\n    addHexagon(Back,Back,Back,X,Y,9,0,0,0,0,0,0.75,0.75,0.75,1,0.5*vh,2)\n    addHexagon(Back,Back,Back,X,Y,6,0,0,0,0,0,0.75,0.75,0.75,1,0.5*vh,3)\n    addHexagon(Back,Back,Back,X,Y,2,0,0,0,0,0,0.75,0.75,0.75,1,0.5*vh,1)\n\nend\n\n------------------------------------------------- Draws Cards per Mining Unit with Stats ----------------------------------------------------(7)\nfunction DrawMiningUnitCard(Top,Front,Center,Back,Font,XX,YY,DataRow)\n    \n    local rx, ry = getResolution()\n    local vw = rx/100\n    local vh = ry/100\n\n    DrawMiningUnitTopDown(Front,Center,Back,XX,YY,tonumber(DataRow.State) )\n\n    local ocr,ocg,ocb = table.unpack(OreTable[DataRow.OreID].color)\n    setNextTextAlign(Front, AlignH_Right, AlignV_Middle)\n    setNextFillColor(Front, ocr/255,ocg/255,ocb/255, 1)\n    setFontSize(Font,3*vh)\n    addText(Front, Font, OreTable[DataRow.OreID].displayNameWithSize, XX + 18*vw, YY - 7*vh)  \n\n    setNextFillColor(Front, 1,1,1, 1)\n    setNextTextAlign(Front, AlignH_Right, AlignV_Middle)\n    setFontSize(Font,3*vh)\n    addText(Front, Font, tostring(math.floor(round(100*tonumber(DataRow.CalibrationRate),1))) .. \n        \"|\" .. tostring(math.floor(round(100*tonumber(DataRow.OptimalRate),1))) .. \" %\", XX + 18*vw, YY - 3.5*vh)\n  \n    local BaseRate = round(tonumber(DataRow.BaseRate))\n    setNextTextAlign(Front, AlignH_Right, AlignV_Middle)\n    setNextFillColor(Front, 1,1,1, 1)\n    setFontSize(Font,3*vh)\n    addText(Front, Font, \n        tostring(math.ceil(round(DataRow.ProductionRate))) .. \n        \"|\".. \n        tostring(math.ceil(BaseRate)) .. \" L/h\"\n        , XX + 18*vw, YY)\n\n        \n    if (86400-tonumber(DataRow.Cooldown)) > 0 then\n        \n        setNextFillColor(Front, 1,1,0, 1)\n        \n        local CDHours = (86400-tonumber(DataRow.Cooldown))/60/60\n        local CDMinutes = round((CDHours - math.floor(CDHours))*60)\n        \n        CooldownText = math.floor(CDHours) .. \"H\" .. math.floor(CDMinutes) .. \"M\"\n        \n    else\n                \n        setNextFillColor(Front, 1,1,0, 1)\n        CooldownText = \"CALIBRATE\"        \n        \n    end\n\n    setNextTextAlign(Front, AlignH_Right, AlignV_Middle)\n    setNextFillColor(Front, 0,0.5,1, 1)\n    setFontSize(Font,3*vh)\n    addText(Front, Font, CooldownText, XX + 18*vw, YY + 7*vh)\n    \n    local CalibrationMargin = tonumber(DataRow.CalibrationRate)-tonumber(DataRow.OptimalRate)\n        \n    if CalibrationMargin < 0 then\n        if (86400-tonumber(DataRow.Cooldown)) > 0 then\n\n            setNextFillColor(Front, 1,0,1, 1)\n            CalibrationText = CooldownText\n\n        else\n\n            setNextFillColor(Front, 1,0,0, 1)\n            CalibrationText = \"CALIBRATE\"     \n\n        end\n        \n    else\n        setNextFillColor(Front, 0,0.5,1, 1)\n                \n        local Days = (3-math.min(tonumber(DataRow.Cooldown)/60/60/24 ,3)) + CalibrationMargin/0.15\n        local Hours = (Days - math.floor(Days))*24\n        local Minutes = (Hours - math.floor(Hours))*60\n        \n        local DaysText = tostring(math.floor(Days))\n        local HoursText = tostring(math.floor(Hours))\n        local MinutesText = tostring(math.floor(Minutes))\n        \n        CalibrationText = DaysText .. \"D\" .. HoursText .. \"H\" .. MinutesText .. \"M\"\n    end\n            \n    setNextTextAlign(Front, AlignH_Right, AlignV_Middle) \n    setFontSize(Font,3*vh)\n    addText(Front, Font, CalibrationText , XX + 18*vw, YY + 3.5*vh)\n\n    local url = OreTable[DataRow.OreID].iconPath\n    local image = loadImage(url)\n    addImage(Top, image, XX - 5*vh, YY - 5*vh, 10*vh, 10*vh)\n            \nend\n\n------------------------------------- Draws Fully Assembled Mining Unit at 15 Degree Perspective ----------------------------------------------(8)\nfunction DrawMiningUnitProfile15Degrees(Front,Center,Back,X,Y,running)\n    \n    local rx, ry = getResolution()\n    local vw = rx/100\n    local vh = ry/100\n\n    if running == 1 then\n        if GColorblind == 1 then\n            r,g,b,a = 0,0.5,1,1\n        else\n            r,g,b,a = 0,1,0.5,1\n        end\n        rot = 120\n    else\n        if RColorblind == 1 then\n            r,g,b,a = 0,0.5,1,1\n        else\n            r,g,b,a = 1,0.2,0.2,1\n        end \n        rot = 0\n    end\n\n    \n    MiningModule(Front,Back,X,Y+6*vh,10*vh,0,rot,r,g,b,a,-15,0.25*vh)\n    MiningModule(Front,Back,X,Y+16*vh,10*vh,0,-rot,r,g,b,a,-15,0.25*vh)\n    MiningModule(Front,Back,X,Y+26*vh,10*vh,0,rot,r,g,b,a,-15,0.25*vh)\n    MiningModule(Front,Back,X,Y+36*vh,10*vh,0,-rot,r,g,b,a,-15,0.25*vh)\n    MiningModule(Front,Back,X,Y+46*vh,10*vh,0,rot,r,g,b,a,-15,0.25*vh)\n    MiningModule(Front,Back,X,Y+56*vh,10*vh,0,-rot,r,g,b,a,-15,0.25*vh)\n\n    DrawBase(Front,Back,X,Y+63*vh,0.55,r,g,b,a)\n\n    MiningModuleCap(Front,X,Y,10*vh,0,120,r,g,b,a)\n\n    addHexagon(Front,Center,Back,X,Y + 77.5*vh,14,-70,0,0,0,0,1,1,1,1,0.5*vh,2)\n    addHexagon(Front,Center,Back,X,Y + 77.5*vh,8,-70,0,0,0,0,1,1,1,1,0.5*vh,3)\n    addHexagon(Front,Center,Back,X,Y + 77.5*vh,3,-70,0,0,0,0,1,1,1,1,0.5*vh,1)\n\n    \n    if running then\n        setNextStrokeColor(Center,200/255, 255/255, 255/255,1)\n        setNextStrokeWidth(Center,0.25*vh)\n        setNextShadow(Center, 1.5*vh,100/255, 180/255, 255/255,1)\n        addLine(Center,89*vw,Y+2.8*vh,89*vw,Y+77.75*vh)\n    end\n    \nend\n\n------------------------------------------------- Draws Summary Stats Bar at the Bottom -----------------------------------------------------(9)\nfunction HorizontalGauge(layer,font,Data,Mass,Vol,X,Y,SX,SY,n,r,g,b,CalibrationTime,StorageTime)\n    \n    local rx, ry = getResolution()\n    local vw = rx/100\n    local vh = ry/100\n\n    local Height = math.ceil(Data/(100/n))\n\n    setDefaultStrokeColor(layer,Shape_Polygon,0,0,0,0)\n    setDefaultShadow(layer,Shape_Polygon,0,0,0,0,0)\n    \n    for jj = 1,Height,1 do\n        setNextFillColor(layer,r,g,b,0.2+(jj^3)*(0.4/(Height^3)))\n        addQuad(layer,\n            X - SX/2 + (jj-1)*SX/n + SX/n*0.2,\n            Y - SY/2,\n            X - SX/2 + (jj-1)*SX/n + SX/n*0.2,\n            Y + SY/2,\n            X - SX/2 + (jj-1)*SX/n + SX/n*0.8,\n            Y + SY/2,\n            X - SX/2 + (jj-1)*SX/n + SX/n*0.8,\n            Y - SY/2)\n    end\n\n    -- Flair --\n    \n    setDefaultStrokeColor(layer,Shape_Line,r,g,b,1)\n    setDefaultStrokeWidth(layer,Shape_Line,0.5*vh)   \n\n    addLine(layer, X - SX/2 - vh, Y - SY/2 - vh, X - SX/2 - vh, Y - SY/2 - vh + SY*0.6 )\n    addLine(layer, X - SX/2 - vh, Y - SY/2 - vh, X - SX/2 - vh + SX*0.4, Y - SY/2 - vh )\n\n    setNextFillColor(layer,r,g,b,1)\n    addCircle(layer,X - SX/2 - vh, Y - SY/2 - vh, 1*vh)\n    \n    setDefaultStrokeColor(layer,Shape_Line,r,g,b,0.5)\n    setDefaultStrokeWidth(layer,Shape_Line,0.25*vh) \n \n    addLine(layer, X + SX/2 + vh, Y + SY/2 + vh, X + SX/2 + vh, Y + SY/2 + vh - SY*0.5 )\n    addLine(layer, X + SX/2 + vh, Y + SY/2 + vh, X + SX/2 + vh - SX*0.4, Y + SY/2 + vh )\n\n    setNextFillColor(layer,r,g,b,1)\n    addCircle(layer,X + SX/2 + vh, Y + SY/2 + vh, 0.5*vh)\n    \n    -- Text --\n    \n    setNextTextAlign(layer, AlignH_Left, AlignV_Middle)\n    setNextFillColor(layer, r, g, b, 1)\n    addText(layer, font, string.format(\"%.1f\",Data) .. \"%\", X+SX/2+2*vh, Y)\n    \n    setNextTextAlign(layer, AlignH_Right, AlignV_Middle)\n    setNextFillColor(layer, r, g, b, 1)\n    addText(layer, font, string.format(\"%.1f\",Vol) .. \"kL\", X + SX/2 + 25*vh, Y)\n    \n    setNextTextAlign(layer, AlignH_Right, AlignV_Middle)\n    setNextFillColor(layer, r, g, b, 1)\n    addText(layer, font, string.format(\"%.1f\",Mass) .. \"t\", X + SX/2 + 39*vh, Y)\n    \n    -- Icon -- \n    \n    local image = loadImage(\"resources_generated/elements/containers/container_001_xl/icons/env_container_001_xl_icon.png\")\n    addImage(layer, image,X - SX/2 - 12*vh, Y - 4*vh, 8*vh, 8*vh)\n    \n    -- Global Cooldown\n          \n    setFontSize(font,3*vh)\n    if CalibrationTime <= 0 then\n        setNextFillColor(layer, 1,0,0, 1)\n        CalibrationText = \"CALIBRATE\"\n    else\n        setNextFillColor(layer, 0,0,1, 1)\n                \n        local Days = math.floor(CalibrationTime)\n        local Hours = (CalibrationTime - Days)*24\n        local Minutes = (Hours - math.floor(Hours))*60\n        \n        local DaysText = tostring(math.floor(Days))\n        local HoursText = tostring(math.floor(Hours))\n        local MinutesText = tostring(math.floor(Minutes))\n        \n        CalibrationText = DaysText .. \"D\" .. HoursText .. \"H\" .. MinutesText .. \"M\"\n    end\n    \n    setNextTextAlign(layer, AlignH_Right, AlignV_Middle)\n    addText(layer, font, CalibrationText, X - SX/2 - 15*vh, Y)\n    setFontSize(font,3*vh)\n    \n    -- Storage Time --\n    setNextTextAlign(layer, AlignH_Center, AlignV_Middle)\n    setNextFillColor(layer, 1, g, 1, 1)\n    \n    if StorageTime <= 0 then\n        setNextFillColor(layer, 1,0,0, 1)\n        StorageText = \"FULL\"\n    else\n        setNextFillColor(layer, 1,1,1, 1)\n                \n        local Days = math.floor(StorageTime/24)\n        local Hours = StorageTime - Days*24\n        local Minutes = (Hours - math.floor(Hours))*60\n        \n        local DaysText = tostring(math.floor(Days))\n        local HoursText = tostring(math.floor(Hours))\n        local MinutesText = tostring(math.floor(Minutes))\n        \n        StorageText = \">\" .. DaysText .. \"D\" .. HoursText .. \"H\" .. MinutesText .. \"M\"\n    end\n    \n    addText(layer, font, StorageText, X, Y)\n\nend\n\n------------------------------------------------------------ General Helpers -----------------------------------------------------------------(10)\n\n--- Splits String at Delimiter ---\nfunction mysplit(inputstr, sep)\n    if sep == nil then\n        sep = \"%s\"\n    end\n    local t={}\n    for str in string.gmatch(inputstr, \"([^\"..sep..\"]+)\") do\n        table.insert(t, str)\n    end\n    return t\nend\n\n-- Rounds Number to Precision ---\nfunction round(num, numDecimalPlaces)\n  local mult = 10^(numDecimalPlaces or 0)\n  return math.floor(num * mult + 0.5) / mult\nend\n\n------------------------------------------------------------ Reference Tables -----------------------------------------------------------------(11)\n\nOreTable = {    \n    [\"4234772167\"]={color={255,255,129},displayNameWithSize=\"Hematite\",iconPath=\"resources_generated/env/voxel/ore/iron-ore/icons/env_iron-ore_icon.png\"},\n    [\"3724036288\"]={color={159,209,255},displayNameWithSize=\"Quartz\",iconPath=\"resources_generated/env/voxel/ore/silicon-ore/icons/env_silicon-ore_icon.png\"},\n    [\"299255727\"]={color={192,255,255},displayNameWithSize=\"Coal\",iconPath=\"resources_generated/env/voxel/ore/carbon-ore/icons/env_carbon-ore_icon.png\"},\n    [\"262147665\"]={color={255,188,68},displayNameWithSize=\"Bauxite\",iconPath=\"resources_generated/env/voxel/ore/aluminium-ore/icons/env_aluminium-ore_icon.png\"},\n    \n    [\"2289641763\"]={color={70,255,197},displayNameWithSize=\"Malachite\",iconPath=\"resources_generated/env/voxel/ore/copper-ore/icons/env_copper-ore_icon.png\"},\n    [\"3086347393\"]={color={255,128,88},displayNameWithSize=\"Limestone\",iconPath=\"resources_generated/env/voxel/ore/calcium-ore/icons/env_calcium-ore_icon.png\"},\n    [\"2029139010\"]={color={129,255,129},displayNameWithSize=\"Chromite\",iconPath=\"resources_generated/env/voxel/ore/chromium-ore/icons/env_chromium-ore_icon.png\"},\n    [\"343766315\"]={color={255,139,157},displayNameWithSize=\"Natron\",iconPath=\"resources_generated/env/voxel/ore/sodium-ore/icons/env_sodium-ore_icon.png\"},\n        \n    [\"4041459743\"]={color={74,255,74},displayNameWithSize=\"Pyrite\",iconPath=\"resources_generated/env/voxel/ore/sulfur-ore/icons/env_sulfur-ore_icon.png\"}, \n    [\"3837858336\"]={color={108,255,255},displayNameWithSize=\"Petalite\",iconPath=\"resources_generated/env/voxel/ore/lithium-ore/icons/env_lithium-ore_icon.png\"},    \n    [\"1050500112\"]={color={75,255,166},displayNameWithSize=\"Acanthite\",iconPath=\"resources_generated/env/voxel/ore/silver-ore/icons/env_silver-ore_icon.png\"},\n    [\"1065079614\"]={color={255,148,124},displayNameWithSize=\"Garnierite\",iconPath=\"resources_generated/env/voxel/ore/nickel-ore/icons/env_nickel-ore_icon.png\"},\n    \n    [\"1866812055\"]={color={255,103,63},displayNameWithSize=\"Gold Nuggets\",iconPath=\"resources_generated/env/voxel/ore/gold-ore/icons/env_gold-ore_icon.png\"},\n    [\"271971371\"]={color={255,166,104},displayNameWithSize=\"Kolbeckite\",iconPath=\"resources_generated/env/voxel/ore/scandium-ore/icons/env_scandium-ore_icon.png\"},\n    [\"3546085401\"]={color={255,132,79},displayNameWithSize=\"Cobaltite\",iconPath=\"resources_generated/env/voxel/ore/cobalt-ore/icons/env_cobalt-ore_icon.png\"},\n    [\"1467310917\"]={color={168,255,73},displayNameWithSize=\"Cryolite\",iconPath=\"resources_generated/env/voxel/ore/fluorine-ore/icons/env_fluorine-ore_icon.png\"},\n    \n    [\"3934774987\"]={color={90,206,255},displayNameWithSize=\"Rhodonite\",iconPath=\"resources_generated/env/voxel/ore/manganese-ore/icons/env_manganese-ore_icon.png\"},\n    [\"629636034\"]={color={255,203,255},displayNameWithSize=\"Ilmenite\",iconPath=\"resources_generated/env/voxel/ore/titanium-ore/icons/env_titanium-ore_icon.png\"},\n    [\"2162350405\"]={color={184,184,255},displayNameWithSize=\"Vanadinite\",iconPath=\"resources_generated/env/voxel/ore/vanadium-ore/icons/env_vanadium-ore_icon.png\"},    \n    [\"789110817\"]={color={231,229,74},displayNameWithSize=\"Columbite\",iconPath=\"resources_generated/env/voxel/ore/niobium-ore/icons/env_niobium-ore_icon.png\"}\n}\n--------------------------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------- Compose --------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------------------\n\nlocal rx, ry = getResolution()\nlocal vw = rx/100\nlocal vh = ry/100\n\nlocal Logo = createLayer()\nlocal Aura0 = createLayer()\nlocal Aura1 = createLayer()\nlocal Back = createLayer()\nlocal Center = createLayer()\nlocal Front = createLayer()\nlocal Top = createLayer()\n\nlocal Font = loadFont(getAvailableFontName(5), 6*vh)\n\nif not _init then\n    \n    NMUs = 0\n    DataTable = {}\n    Empty = {}\n    LocationMessageWillBeSent = false\n    \n    _init = true\n    \nend\n\nPayload = getInput()\n\nif Payload ~= nil and Payload ~= '' then\n        \n    PayloadType = mysplit(Payload, \"&\")    \n    \n    Info = mysplit(PayloadType[1], \"$\")\n    NMUs = tonumber(Info[1])\n    Mass = tonumber(Info[2])\n    Vol = tonumber(Info[3])\n    MaxVol = tonumber(Info[4])\n    ConstructName = Info[5]\n    GColorblind = tonumber(Info[6])\n    RColorblind = tonumber(Info[7])\n    ConstructPos = Info[8]\n    AcquiredTime = Info[9]\n    ConstructID = Info[10]\n       \n    if PayloadType[2] ~= nil and PayloadType[2] ~= '' then\n        \n        DataRows = mysplit(PayloadType[2], \"#\")  \n        DataTable = {}\n        for idx, v in ipairs(DataRows) do\n            CurrentRow = mysplit(v, \"$\") \n            DataTable[idx] = {\n                State = CurrentRow[1],\n                OreID = CurrentRow[2],\n                BaseRate = CurrentRow[3],\n                Efficiency = CurrentRow[4],\n                Adjacency = CurrentRow[5],\n                CalibrationRate = CurrentRow[6],\n                OptimalRate = CurrentRow[7],\n                ProductionRate = CurrentRow[8],\n                Cooldown = CurrentRow[9],\n                Position = CurrentRow[10]\n            }\n        end\n        \n    end\n\nend\n\nBackground(Logo,Aura0,Aura1)\nDrawMiningUnitProfile15Degrees(Front,Center,Back,89*vw,11*vh,1)\nDrawMiningUnitProfile15Degrees(Front,Center,Back,11*vw,11*vh,0)\n\nif DataTable ~= {} and DataTable[1] ~= nil then\n\n    counter = 0\n    for ii = 1,2 do\n        for jj = 1,4 do\n\n            counter = counter + 1\n\n            if counter <= NMUs then\n\n                DrawMiningUnitCard(Top,Front,Center,Back,Font,30*vw + (ii-1)*27.5*vw,15*vh + (jj-1)*20*vh, DataTable[counter])    \n\n            end\n\n        end\n    end\n\n    local Productions = {}\n    local TotalProduction = 0\n    local CalibTimes = {}\n    local CDTimes = {}\n\n    for i ,v in ipairs(DataTable) do\n\n        if Productions[v.OreID] then \n            Productions[v.OreID] = Productions[v.OreID] + tonumber(v.ProductionRate)\n        else\n            Productions[v.OreID] = tonumber(v.ProductionRate)\n        end\n\n        TotalProduction = TotalProduction + tonumber(v.ProductionRate)\n\n        CalibrationMargin = tonumber(v.CalibrationRate)-tonumber(v.OptimalRate)\n        CDTimes[i] = (86400-tonumber(v.Cooldown))/60/60\n        if CalibrationMargin > 0 then\n            CalibTimes[i] = (3-math.min(tonumber(v.Cooldown)/60/60/24 ,3)) + CalibrationMargin/0.15             \n        else\n            CalibTimes[i] = CDTimes[i]/24  \n        end\n    end\n\n    StorageTime = (MaxVol - Vol)/TotalProduction\n\n    table.sort(CalibTimes)\n    CalibrationTime = CalibTimes[1]\n\n    table.sort(CDTimes)\n    CDTime = CDTimes[1]\n\n    HorizontalGauge(Front,Font,100*Vol/MaxVol,Mass/1000,Vol/1000,79.5*vh,90*vh,15*vw,5*vh,20,0.75,0.75,0.1,CalibrationTime,StorageTime)\n\n\n    ProdText = ''\n    for k,v in pairs(Productions) do\n        ProdText = ProdText .. \"#\" .. k .. \"$\" .. round(v,1)\n    end\n\n    MessageOut = round(StorageTime,2) .. \"$\" .. Vol .. \"$\" .. Mass .. \"$\" .. round(CalibrationTime,2) .. \"$\" .. round(CDTime,2) .. \"$\" .. ConstructName ..\n    \"$\" .. ConstructPos .. \"$\" .. AcquiredTime .. \"$\" .. ConstructID .. \"&\" .. ProdText\n\n    setOutput(MessageOut) \n\nend\n\nrequestAnimationFrame(1)]])",
            "filter": {
                "args": [],
                "signature": "onStart()",
                "slotKey": "-1"
            },
            "key": "2"
        }
    ],
    "methods": [],
    "events": []
}